/* Generated By:JavaCC: Do not edit this line. rastreabilityMatrix.java */
package rastreability;
import java.io.*;
import java.util.*;
import analise.Token;

import analise.ParseException;

@SuppressWarnings("all")
public class rastreabilityMatrix implements rastreabilityMatrixConstants {
	static Matriz matriz = new Matriz();
	static String linhaatual = new String();
	static String coluna1 = new String();
	static int quantidade;
	static String tipoMatriz = new String();
	static Vector<String> colunas = new Vector<String> () ;
	static Vector<String> colunasaovmer = new Vector<String> () ;
	static Vector<String> linhastrans = new Vector<String>();
	static Vector<String> celulastrans = new Vector<String>();
	static Vector<String> colunasrel = new Vector<String>();
	static Vector<Linha> colunaaovmer = new Vector<Linha>();
	static Vector<Linha> colunatrans = new Vector<Linha>();
	static Vector<Linha> colunarel = new Vector<Linha>();
	static Vector<String> linhas = new Vector<String> () ;
	static int aux;
	static int contador = 0;
	static int contatrans=0;
	public static void main(String args[]) throws ParseException {

		
	contador = 0;

  }

  static final void setColunas(){
    
	  if(tipoMatriz.equals("aovmer")){
	  //System.out.println("colunasaovmer: " + colunasaovmer);
	  //if(colunaaovmer.size()>0){
		  //for(int i=0; i<colunaaovmer.size(); i++){
			  //colunaaovmer.addElement(new Coluna(colunasaovmer.elementAt(i)));
		//	  System.out.println("colunas.elementAt(i).getID: " + colunaaovmer.elementAt(i).getColuna());
		//	  System.out.println("colunas.elementAt(i).getLinha: " + colunaaovmer.elementAt(i).getLinhas());
		//	  System.out.println("colunas.elementAt(i).getCelula: " + colunaaovmer.elementAt(i).getCelula());}
			  matriz.atualizaMatriz(tipoMatriz, colunaaovmer, colunaaovmer.size());}
	  
	  if(tipoMatriz.equals("transversalidade")){
		  if(colunatrans.size()>0){
			  for(int i=0; i<colunatrans.size(); i++){
				  //System.out.println("colunatrans.elementAt(i).getColunas(): " + colunatrans.elementAt(i).getColunas());
				  for(int j=i+1; j<colunatrans.size(); j++){
				  //colunatrans.addElement(new Coluna(colunastrans.elementAt(i)));
					  if(colunatrans.elementAt(i).getColunas().equals(colunatrans.elementAt(j).getColunas()) && 
						  colunatrans.elementAt(i).getLinhas().equals(colunatrans.elementAt(j).getLinhas())){
						  colunatrans.remove(i);  }  }  }
			  
			  for(int i=0; i<colunatrans.size(); i++){
				  for(int j=i+1; j<colunatrans.size(); j++){
				  //colunatrans.addElement(new Coluna(colunastrans.elementAt(i)));
					  if(colunatrans.elementAt(i).getColunas().equals(colunatrans.elementAt(j).getColunas()) && 
							  colunatrans.elementAt(i).getLinhas().equals(colunatrans.elementAt(j).getLinhas())
					  ){
						  colunatrans.remove(i);  
					  }
					  }
				  
			  }
		}
		  
		  if(colunatrans.size()>0){
			  for(int i=0; i<colunatrans.size(); i++){
				  //colunatrans.addElement(new Coluna(colunastrans.elementAt(i)));
				  //System.out.println("colunas.elementAt(i).getID: " + colunatrans.elementAt(i).getColunas());
				  //System.out.println("colunas.elementAt(i).getLinha: " + colunatrans.elementAt(i).getLinhas());
				  //System.out.println("colunas.elementAt(i).getCelula: " + colunatrans.elementAt(i).getCelula());
			  }
		}
		  
		  
		  matriz.atualizaMatriz(tipoMatriz, colunatrans, colunatrans.size());
	  
	  }
	  
	  if(tipoMatriz.equals("contribuicao")){
		  //System.out.println("colunasrel: " + colunasrel);
		  if(colunarel.size()>0){
			 for(int i=0; i<colunarel.size(); i++){
				  //colunarel.addElement(new Coluna(colunasrel.elementAt(i)));
				  //System.out.println("colunas.elementAt(i).getID: " + colunarel.elementAt(i).getColunas());
				  //System.out.println("colunas.elementAt(i).getLinha: " + colunarel.elementAt(i).getLinhas());
				  //System.out.println("colunas.elementAt(i).getCelula: " + colunarel.elementAt(i).getCelula());
			  }
		}
		  
		  matriz.atualizaMatriz(tipoMatriz, colunarel, colunarel.size());
	  }
	    
  }
  
  
  static final public int rastreability_matrix(String tipo) throws ParseException {
	  tipoMatriz = tipo;
	  contador = 0;
Vector<String> colunasvct= new Vector<String>();
String celula = new String();
    jj_consume_token(RASTREABILITY_MATRIX);
    jj_consume_token(25);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RELATIONSHIP:
      jj_consume_token(RELATIONSHIP);
      break;
    case CONTRIBUTION:
      jj_consume_token(CONTRIBUTION);
      break;
    case ERMODEL:
      jj_consume_token(ERMODEL);
      break;
    case CROSSCUTTING:
      jj_consume_token(CROSSCUTTING);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      //System.out.println("DEFAULT");
      throw new ParseException();
    }
    jj_consume_token(26);
    jj_consume_token(ALPHABETIC);
    jj_consume_token(27);
    jj_consume_token(28);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LINE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      line();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLUMN:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      column(contador);
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CELL:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      celula = cell(contador);
    }
    jj_consume_token(29);
    jj_consume_token(0);
    
    setColunas();
  {if (true) return 0;}
  //{if (false) return 0;}
    throw new Error("Missing return statement in function");
  }

  static final public String nomeComponente() throws ParseException {
Token tok = new Token();
Vector<String> nomesvct = new Vector<String> ();
String descr = new String();
String topic = new String();
    label_4:
    while (true) {
      tok = jj_consume_token(ALPHABETIC);
        if(!tok.image.equals("task") && !tok.image.equals("goal") && !tok.image.equals("softgoal")){
        nomesvct.addElement(tok.image);
        }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 30:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_5;
      }
      topic = topic();
  nomesvct.addElement(topic);
    }
            for (int i = 0; i < nomesvct.size(); i++) {
            descr +=(String)nomesvct.elementAt(i) + " ";}
        //System.out.println(descr);
        {if (true) return descr;}
    throw new Error("Missing return statement in function");
  }

  static final public String topic() throws ParseException {
Token tok = new Token();
Vector<String> topicvct = new Vector<String> ();
String topicdescr = new String();
String nome = new String();
    tok = jj_consume_token(30);
    topicvct.addElement(tok.image);
    label_6:
    while (true) {
      tok = jj_consume_token(ALPHABETIC);
    topicvct.addElement(tok.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_6;
      }
    }
    tok = jj_consume_token(31);
    topicvct.addElement(tok.image);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_7;
      }
      nome = nomeComponente();
    {//System.out.println("em softgoal tok.image: "+ tok.image);
        }
   topicvct.addElement(nome);
    }
            for (int i = 0; i < topicvct.size(); i++) {
            topicdescr +=(String)topicvct.elementAt(i);}
        //System.out.println(topicdescr);
        {if (true) return topicdescr;}
    throw new Error("Missing return statement in function");
  }

  static final public void line() throws ParseException {
//System.out.println("Entrou em line");
String afetado = new String();
String celula = new String();
Token tok;
String coluna;
String topic = new String();
String nome = new String();
    jj_consume_token(LINE);
    jj_consume_token(25);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_8;
      }
      nome = nomeComponente();
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 32:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_9;
      }
      jj_consume_token(32);
      nome = nomeComponente();
    }
    //System.out.println("retornou p/ line");
    
    
	  if(tipoMatriz.equals("aovmer")){
		  //if(!colunasaovmer.contains(componentesvct.elementAt(i))){  
		  //System.out.println("linhaatual: " + linhaatual);
		  //System.out.println("componentesvct: " + componentesvct);
		  colunaaovmer.addElement(new Linha(nome));
		  //System.out.println("contador: " + contador);
		  contador++;
		  //colunasaovmer.addElement(componentesvct.elementAt(i));
		  //System.out.println("linhas.elementAt(j): " + linhas.elementAt(j));
		 
		  //}
		  
		  }
	  
	  if(tipoMatriz.equals("contribuicao")){
		  //if(!colunasaovmer.contains(componentesvct.elementAt(i))){  
		  //System.out.println("linhaatual: " + linhaatual);
		  //System.out.println("componentesvct: " + componentesvct);
		  colunarel.addElement(new Linha(nome));
		  contador++;
		  //colunasaovmer.addElement(componentesvct.elementAt(i));
		  //System.out.println("linhas.elementAt(j): " + linhas.elementAt(j));
		 
		  //}
		  }
    //System.out.println("nome: " + nome);
    jj_consume_token(27);
    jj_consume_token(26);
//if(!tok.image.equals("task") && !tok.image.equals("goal") && !tok.image.equals("softgoal")){
afetado=nome;
//afetado=tok.image;
linhaatual=nome;
//System.out.println("linhaatual: " + linhaatual);
//}

    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLUMN:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_10;
      }
      coluna = column(contador);
      //System.out.println("retornou p/ line");
      //System.out.println("coluna: " + coluna);
    }
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CELL:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_11;
      }
      celula = cell(contador);
      //System.out.println("retornou p/ line");
      //System.out.println("celula: " + celula);
    }
  }

  static final public String column(int cont) throws ParseException {
	  contador = cont;
	  int j = linhas.size()-1;
	  //contatrans=0;
	  //System.out.println("Entrou em coluna");
	  String ref = new String();
	  String celula = new String();
	  String afetado = new String();
	  Vector<String> refvct= new Vector<String> ();
	  Vector<String> componentesvct= new Vector<String> ();
	  Token tok;
	  String nome = new String();
	  String topic = new String();
	      jj_consume_token(COLUMN);
	      jj_consume_token(25);
	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	      case ALPHABETIC:
	      case 27:
	        label_12:
	        while (true) {
	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	          case ALPHABETIC:
	            ;
	            break;
	          default:
	            jj_la1[12] = jj_gen;
	            break label_12;
	          }
	          nome = nomeComponente();
	          //topic = topic();
	  //if(!tok.image.equals("task") && !tok.image.equals("goal") && !tok.image.equals("softgoal")){
	  afetado=nome;
	  //System.out.println("nome: " + nome);
	  //afetado=tok.image;
	  //afetadostr=nome;
 
	  {   componentesvct.addElement(afetado);
      //System.out.println("componentesvct: "+componentesvct);
      }
	  
	  
	  {   //componentesvct.addElement(afetado);
      //System.out.println("componentesvct: "+componentesvct);
          
  
	  if(tipoMatriz.equals("contribuicao")){
		  
		  if(componentesvct.size()>0){
		  for(int i=0; i<componentesvct.size();i++){
		  colunarel.elementAt(contador-1).addinColunas(componentesvct.elementAt(i));  
		  //System.out.println(componentesvct.elementAt(i));
		  }	  
		  }
  
  }
  }
	  
	  
	  
	  if(tipoMatriz.equals("aovmer")){	 
	  //System.out.println("afetado: "+ afetado);
	  colunaaovmer.elementAt(contador-1).setColunas(afetado);  	  
	  }
	  


	  //}

	          label_13:
	          while (true) {
	            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	            case 32:
	              ;
	              break;
	            default:
	              jj_la1[13] = jj_gen;
	              break label_13;
	            }
	            jj_consume_token(32);
	            nome = nomeComponente();
	  //if(!tok.image.equals("task") && !tok.image.equals("goal") && !tok.image.equals("softgoal")){
	  afetado=nome;
	  //afetado=tok.image;
	  //afetadostr=tok.image;
	 // System.out.println("AFETADO: " + afetado);
	  

	  
	  {   componentesvct.addElement(afetado);
	      //System.out.println("componentesvct: "+componentesvct);
	          
	  
		  if(tipoMatriz.equals("contribuicao")){
			  
			  if(componentesvct.size()>0){
			  for(int i=0; i<componentesvct.size();i++){
			  colunarel.elementAt(contador-1).addinColunas(componentesvct.elementAt(i));  
			  //System.out.println(componentesvct.elementAt(i));
			  }	  
			  }
	  
	  }
	  }
	  //}

	          }
	        }
	        jj_consume_token(27);
	        jj_consume_token(26);
	        
	  quantidade = componentesvct.size();
	 
	  
if(componentesvct.size()>0){
   
		  for(int i=0; i<componentesvct.size(); i++){
		  if(tipoMatriz.equals("transversalidade")){
			  //if(!colunastrans.contains(componentesvct.elementAt(i))){  
			  //System.out.println("linhaatual: " + linhaatual);
			  //System.out.println("componentesvct: " + componentesvct);
			  //System.out.println("componentesvct(i): " + componentesvct.elementAt(i));
			  colunatrans.addElement(new Linha(linhaatual, componentesvct.elementAt(i)));
			  contatrans++;
			  //colunastrans.addElement(componentesvct.elementAt(i));
			  //}
			  //System.out.println("LINHA:" + colunatrans.elementAt(i).getLinhas());  
		    }
		  }} 
		  
		  

		  
		  //}
		  
		  //}
	  
	  
	  
	  //matriz.atualizaMatrizColunas(tipoMatriz, componentesvct, componentesvct.size());
	  
	  //afetado = afetadostr;

	        break;
    case GOAL_REF:
    case TASK_REF:
    case SOFTGOAL_REF:
    case 25:
      label_14:
      while (true) {
    ref = references();
    //System.out.println("ref: " + ref);
    refvct.addElement(ref);
    colunas.addElement(ref);
    //System.out.println("refvct: "+refvct);


    	  if(tipoMatriz.equals("transversalidade")){
    	  //if(!linhastrans.contains(linhaatual)){
    	  //System.out.println("linhaatual: " + linhaatual);
    	  //System.out.println(refvct);
    	  colunatrans.addElement(new Linha(linhaatual, refvct));
    	  contatrans++;
    	  }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GOAL_REF:
        case TASK_REF:
        case SOFTGOAL_REF:
        case 25:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_14;
        }
      }
    
    //System.out.println("linhaatual: " + linhaatual);
    
    for(int i=0; i<refvct.size(); i++){
  	  
  	  if(tipoMatriz.equals("aovmer")){
  	  //if(!colunasaovmer.contains(refvct.elementAt(i))){
  	  colunaaovmer.addElement(new Linha(linhaatual));
  	  //colunasaovmer.addElement(refvct.elementAt(i));
  	  
  	  //}
  	  }
  	  
  	  }
 
    	 //aux=0;
    	 for(int k = aux ; k< colunaaovmer.size(); k++){
        	 aux++;
        	 
        	 //for(int i=0; i<refvct.size(); i++){
        	  if(tipoMatriz.equals("aovmer")){
        	  //if(!colunastrans.contains(refvct.elementAt(i))){
        	  colunaaovmer.elementAt(k).setColunas(refvct);
        	  //colunastrans.addElement(refvct.elementAt(i));
        	  //}
        	  }
        	  //}  
    	      }
    	 
    	 
    	 aux=0;
    	 for(int k = aux ; k< colunarel.size(); k++){
        	 aux++;
        	 
        	 //for(int i=0; i<refvct.size(); i++){
        	  if(tipoMatriz.equals("contribuicao")){
        	  //if(!colunastrans.contains(refvct.elementAt(i))){
        	  colunarel.elementAt(k).setColunas(refvct);
        	  //colunastrans.addElement(refvct.elementAt(i));
        	  //}
        	  }
        	  //}  
    	      }
    	    	 
quantidade = refvct.size();



//matriz.atualizaMatrizColunas(tipoMatriz, refvct, refvct.size());

afetado = linhaatual;

      jj_consume_token(27);
      jj_consume_token(26);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LINE:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_15;
      }
      line();
    }
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CELL:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_16;
      }
      if(tipoMatriz.equals("transversalidade")){
      celula = cell(contatrans);
      }else{
      celula = cell(contador);  
      }
      //System.out.println("cell: " + celula);
      celulastrans.addElement(celula);

    }
  
    if(tipoMatriz.equals("transversalidade")){
  	  for(int k = 0 ; k< celulastrans.size(); k++){
  	  //colunatrans.elementAt(k).setCelula(celulastrans.elementAt(k));	 
  	  }
  	//System.out.println("colunas: " + colunas); 
	  //System.out.println("colunas.size(): " + colunas.size());
	  //System.out.println("colunatrans.size(): " + colunatrans.size());
    }
  return celula + nome;
  }

  static final public String references() throws ParseException {
//System.out.println("Entrou em references");
String adicionado = new String();
Token tok;
String nome=new String();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GOAL_REF:
      case TASK_REF:
      case SOFTGOAL_REF:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_17;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GOAL_REF:
        jj_consume_token(GOAL_REF);
        break;
      case SOFTGOAL_REF:
        jj_consume_token(SOFTGOAL_REF);
        break;
      case TASK_REF:
        jj_consume_token(TASK_REF);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(33);
    }
    jj_consume_token(25);
    nome = nomeComponente();
 adicionado=nome;
//System.out.println("ADICIONADO: " + adicionado);
    jj_consume_token(26);
    jj_consume_token(ALPHABETIC);
    jj_consume_token(26);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_18;
      }
      jj_consume_token(ALPHABETIC);
      jj_consume_token(26);
    }
    jj_consume_token(27);
    //System.out.println("adicionado: " + adicionado);
 {if (true) return adicionado;}
    throw new Error("Missing return statement in function");
  }

  static final public String cell(int cont) throws ParseException {
	  contador = cont;
	  //System.out.println("Entrou em celulas");
String celula = new String();
Token tok;
Token tok2;
String indicacao1 = new String(" ");
String indicacao2 = new String(" ");
    jj_consume_token(CELL);
    jj_consume_token(25);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RELATIONSHIP:
      case CROSSCUTTING:
      case ERMODEL:
      case CONTRIBUTION:
      case ALPHABETIC: 
      case 28:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_19;
      }
      label_20:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 28:
              ;
              break;
            default:
              jj_la1[22] = jj_gen;
              break label_20;
            }
            tok = jj_consume_token(28);
            celula = celula + tok.image;
          }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABETIC:
        tok = jj_consume_token(ALPHABETIC);
        break;
      case CONTRIBUTION:
        tok = jj_consume_token(CONTRIBUTION);
        break;
      case RELATIONSHIP:
        tok = jj_consume_token(RELATIONSHIP);
        break;
      case ERMODEL:
        tok = jj_consume_token(ERMODEL);
        break;
      case CROSSCUTTING:
        tok = jj_consume_token(CROSSCUTTING);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      celula = celula + tok.image;
      
      label_21:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 29:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_21;
            }
            tok = jj_consume_token(29);
            celula = celula + tok.image;
          }
 
 //System.out.println("CELULA: " + celula);
    }
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CROSSCUTTING:
      case CONTRIBUTION:
      case CORRELATION:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_20;
      }
      relationship_type();
    }
    jj_consume_token(27);
    jj_consume_token(26);
   //System.out.println("celula em CELL: "+celula);
   //System.out.println("afetado em CELL: "+afetadostr);
   
	  if(tipoMatriz.equals("aovmer")){
		  colunaaovmer.elementAt(contador-1).setCelula(celula);  
		  } 
	  
	  if(tipoMatriz.equals("contribuicao")){
		  //System.out.println(contador-1);
		  colunarel.elementAt(contador-1).setCelula(celula);   
		  }
	  
	  if(tipoMatriz.equals("transversalidade")){
		  //System.out.println(contador-1);
		  colunatrans.elementAt(contador-1).setCelula(celula);   
		  }
    
    //matriz.atualizaMatrizCelulas(tipoMatriz,linhaatual, celula, quantidade, componentesvct.size());
   
   
   
   label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LINE:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_21;
      }
      line();
    }
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLUMN:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_22;
      }
      column(contador);
    }
        {if (true) return celula;}
    throw new Error("Missing return statement in function");
  }

  static final public void relationship_type() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONTRIBUTION:
      jj_consume_token(CONTRIBUTION);
      break;
    case CORRELATION:
      jj_consume_token(CORRELATION);
      break;
    case CROSSCUTTING:
      jj_consume_token(CROSSCUTTING);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public rastreabilityMatrixTokenManager token_source;
  static JavaCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x11a0,0x200,0x400,0x800,0x20000,0x40000000,0x20000,0x20000,0x20000,0x0,0x400,0x800,0x20000,0x0,0x201c000,0xa03c000,0x200,0x800,0x1c000,0x1c000,0x20000,0x211a0,0x211a0,0x3080,0x200,0x400,0x3080,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public rastreabilityMatrix(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public rastreabilityMatrix(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    //jj_initialized_once = true;
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new rastreabilityMatrixTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public rastreabilityMatrix(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    //jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new rastreabilityMatrixTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public rastreabilityMatrix(rastreabilityMatrixTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
   //jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(rastreabilityMatrixTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    //token.next.beginColumn=0;
    if ((oldToken = token).next != null) 
    token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    //System.out.println("R: " + token.next.beginColumn);
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[34];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 34; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
      //System.out.println("(int[])jj_expentries.get(i): " + (int[])jj_expentries.get(i));
    }
    //System.out.println("exptokseq: " + exptokseq.length);
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
